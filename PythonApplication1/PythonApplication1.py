request = ''
DATABASE = { # библиотека команд git
    'status': 'показать статус файлов в каталогах проекта в подробном режиме, для упрощенного вывода используются ключи <-s или --short>',
    'status -s': 'показать статус в упрощенном выводе с пометками',
    'status --short': 'Упрощенный вывод статуса файлов с пометками',
    'gitignore': 'создать файл .gitignore со следующими правилами: 	\nПустые строки, а также строки, начинающиеся с #, игнорируются. \nСтандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов. \nЧтобы избежать рекурсии используйте символ слеш (/) в начале шаблона. \nЧтобы исключить каталог добавьте слеш (/) в конец шаблона. \nМожно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа. \nGlob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. ',
    '.gitignore': 'список игнорирования файлов по условиям (правилам). GitHub поддерживает полный список примеров .gitignore файлов https://github.com/github/gitignore это может стать отправной точкой для .gitignore в вашем проекте.',
    'diff': 'показать изменения, что изменили, но пока не проиндексировали в файлах',
    'diff --staged': 'показать что изменили и проиндексировали и что войдет в следующий коммит',
    'diff --cached': 'показать, что изменили и проиндексировали и что войдет в следующий коммит',
    'init': 'создать новый репозиторий из текущего каталога, создастся в текущем каталоге новый подкаталог с именем .git, \nсодержащий все необходимые файлы репозитория — структуру Git репозитория.',
    'add': 'проиндексировать внесенные в файл изменения или добавит под версионный контроль новый файл для того чтобы начать его отслеживать \nНапример: git add README',
    'clone': 'клонирование или создание копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад. Пишется как git clone <URL>',
    'commit': 'коммитить, закоммитить, зафиксировать все проиндексированные изменения в коммит',
    'commit -a': 'закоммитить автоматически проиндексирует и закоммитит все изменения отслеживаемых файлов минуя команду add потому что флаг -a включает все файлы. \nЭто удобно, но будьте осторожны: флаг -a может включить в коммит нежелательные изменения.',
    'rm': 'удалить файл из Git и из рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый» \nЕсли вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f. \n Если вы хотите удалить файл из индекса и не отслеживать его, но оставить в каталоге используйте --cached',
    'rm -f': 'удалить файл из Git и из рабочего каталога уже измененный и проиндексированный файл , так что в следующий раз вы не увидите его как «неотслеживаемый». \n Если вы хотите удалить файл из индекса и не отслеживать его, но оставить в каталоге используйте --cached',
    'rm --cached':'удалить и не отслеживать файл из индекса Git, но оставить в каталоге.'
}
gitignores = { # правила записи в файл .gitignore
    
    '*': 'соответствует 0 или более символам',
    '[abc]': 'соответствует любому символу из указанных в скобках (в данном примере a, b или c)',
    '?': 'соответсвует одному символу',
    '[0-9]': 'соотвествует любому символу из интервала (в данном случае от 0 до 9) ',
    '**': 'указывает на вложенные каталоги: a/**/z соответсвует a/b/z, a/b/c/z, a/z...'
}
abd_status_out = { # Сокращенный вывод статуса status
    '??': 'неотслеживаемые файлы',
    'А_': 'отслеживаемые файлы',
    '_M': 'модифицированные файлы',
    'M_': 'проиндексированные файлы',
    'MM': 'файлы проиндексированы и потом модифицированны'
}

abd_status_db = { # Сокращенный вывод статуса status
    '??': 'неотслеживаемые файлы',
    'А_': 'отслеживаемые файлы',
    '_M': 'модифицированные файлы',
    'M_': 'проиндексированные файлы',
    'MM': 'файлы проиндексированы и потом модифицированны'
}

cases = {
    'rm': 'rm_case_db',
    'status -s': 'abd_status_db'

}

rm_case_db = {
    'git rm --cached README': 'В команду git rm можно передавать файлы, каталоги или шаблоны.',
    'git rm log/\*.log': 'Обратите внимание на обратный слеш (\) перед *. Он необходим из-за того, что Git использует свой собственный \nобработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. \nЭта команда удаляет все файлы, имеющие расширение .log и находящиеся в каталоге log/.',
    'git rm \*~': 'Эта команда удаляет все файлы, имена которых заканчиваются на ~.',
}

def print_case(in_command, case_command):
    print ('Пример команды ' + in_command + ':')
    for in_key in range(len(case_command)): #Выводим список примеров команды с примечаниями
        print ('$ ' + in_key)
        print ('# ' + case_command[in_key])
    return


def runner(command):
    if command in DATABASE:
        if command == 'status -s' or command == 'status --short':
            print (DATABASE[command]+':')
            for out in abd_status_out: #Выводим список статусов с пометками в столбцы
                print (out + ' - ' + abd_status_out[out])
            return '--> пометки имеют 2 столбца состояния <--\n'
        elif command == 'gitignore' or command == '.gitignore':
            print (DATABASE['gitignore'])
            input ('>>> press Enter <<<')
            for argum in gitignores:
                print (argum + ' - ' + gitignores[argum])
            another = input ('Рассмотрим пример? (y/yes, n/no):')
            if another == 'y' or another == 'yes':
                print ('# Исключить все файлы с расширением .a \n*.a')
                print ('# Но отслеживать файл lib.a даже если он подпадает под исключение выше \n!lib.a')
                print ('# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO \n/TODO')
                print ('# Игнорировать все файлы в каталоге build/ \nbuild/')
                print ('# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt \ndoc/*.txt')
                print ('# Игнорировать все .txt файлы в каталоге doc/ \ndoc/**/*.txt')
                another = ''
            return '.gitignore - это ' + DATABASE['.gitignore']
        elif command in cases:
            print_case(command, cases[command])

        else:
            return f'эта команда - {DATABASE[command]}'
    else:
        return 'неизвестная команда'

def check_git_request(git_comm):   # проверяем на наличие в команде элемента git
    try:                           # пробуем удалить git из строки
        git_list = git_comm.split( ) # переводим  строку в коллекцию
        git_list.remove('git') # удаляем git из коллекции
        count_git_list = len(git_list) # узнаемколичество элементов в коллекции
        if count_git_list > 1: # Если элементов в коллекции больше одного - соберем их в строку
            checked_git = ' '.join(git_list)
        else: # в противном случае результатом будет строка из элемента коллекции
            checked_git = git_list[0]
        print(checked_git) # проверим результат после удаления элемента git

    except ValueError: # если git в строке не находится получаем ошибку проверки
        checked_git = git_comm # и результатом возвращаем неизменную строку
    return checked_git

i = 'y'
while i == 'y' or i =='yes':
    print('Введите команду git')
    request = input('>')
    request = check_git_request(request)
    print (runner(request))
    i=input('Еще будут вопросы? (y/yes, n/no):')